# InMem — In-Memory Timestamped Byte-Data Store

This repository contains a small in-memory key/value store that models timestamped fields with optional TTL (time-to-live), basic scanning, and a simple backup/restore engine.

Files
- `byte_data_db.py`: **Database Core**: provides the `ByteDataDB` singleton class that stores `ByteDataRecord` objects in-memory and exposes timestamped CRUD operations (`set_at`, `get_at`, `delete_at`), plus helpers to get and clear the entire data store.

- `byte_data_record.py`: **Record Container**: contains `ByteDataRecord`, a container for fields on a single key. It maps field names to `ByteDataField` (or list field) instances and exposes operations to `set_field`, `get_field`, `delete_field`, and scanning helpers (`scan_fields`, `scan_fields_by_prefix`). Scans return lists of `(field_name, value)` tuples for fields that are still alive at a given timestamp.

- `byte_data_field.py`: **Field (Scalar)**: defines `ByteDataField`, an implementation of `IByteDataField` representing a single value with `created_at` and optional `ttl`. It implements `is_alive(timestamp)` to determine whether the field has expired.

- `byte_data_list_field.py`: **Field (List)**: defines `ByteDataListField`, intended to represent a list-valued field with the same `created_at`/`ttl` semantics. (See Notes below for a bug in this implementation.)

- `byte_data_search.py`: **Search / Scan Layer**: defines `InMemorySearch` (subclassing `ByteDataDB`) and provides convenience scan methods `scan_at` and `scan_by_prefix_at` that return formatted strings like `"field(value)"` for fields alive at a timestamp.

- `byte_data_backup_restore.py`: **Backup / Restore Engine**: `ByteDataBackupEngine` walks the current DB and snapshots active fields for a given timestamp, storing (timestamp, snapshot) pairs. `restore` finds the most-recent snapshot at or before a requested time and repopulates the DB using the snapshot, preserving remaining TTL where applicable.

- `IByteDataField.py`: **Field Interface**: abstract base class `IByteDataField` declaring `is_alive(timestamp)` that concrete field types must implement.

How it works (high level)
- Keys map to `ByteDataRecord` instances. Each record maps field names to field objects (scalar or list).
- Fields carry `created_at` timestamps and optional `ttl`. `is_alive(timestamp)` is used to determine visibility of a field at any point in time.
- `ByteDataDB.set_at(key, field, value, timestamp, ttl)` writes (or overwrites) a field at a given timestamp.
- Scans and get operations always check `is_alive(timestamp)` so expired fields are invisible.
- Backups snapshot only currently-alive fields and store the remaining TTL so that a restore will re-create fields with their remaining lifetime.

Usage example (informal)
- Create or get the DB singleton:

```
from byte_data_db import ByteDataDB
db = ByteDataDB.get_instance()
db.set_at('user:1', 'name', 'Alice', timestamp=1000, ttl=None)
name = db.get_at('user:1', 'name', timestamp=1001)
```

Notes & Known Issues
- `byte_data_list_field.py`: the constructor is buggy — it references `self.value` before it is defined and tries to append incorrectly. It should probably initialize `self.value` from the provided list or ensure appends are handled explicitly. Example fix: `self.value = value if value is not None else []` and append behavior handled elsewhere.
- `byte_data_record.py`:
  - `scan_fields_by_prefix(self, prefix, timestamp)` currently filters by `f.value.startswith(prefix)` (checks the field *value*), but the method name suggests it should filter by field *name* prefix. Confirm intended behavior and adjust accordingly.
  - `scan_fields`/`scan_fields_by_prefix` use `result.sort(lambda x: x[0])` — this works because the lambda is passed positionally as the `key` argument, but it may be clearer to use `result.sort(key=lambda x: x[0])`.
- `byte_data_backup_restore.py`: the backup stores snapshots as a shared `_snapshot` dict and appends it to `_backups`; if not careful, subsequent backups may mutate earlier snapshots. Consider copying snapshots (deep copy) before appending to `_backups`.

Suggested next steps
- Run unit tests (if any) or add a small test script that exercises set/get/delete/scan and backup/restore flows.
- Fix `ByteDataListField` constructor and clarify `scan_fields_by_prefix` behavior.

If you want, I can:
- add a small `tests/` script demonstrating usage and verifying behavior, or
- patch the issues noted above (e.g., fix `ByteDataListField`) and add tests.

---
Generated by GitHub Copilot assistant — let me know which next step you'd like.
